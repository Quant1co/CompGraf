<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lab 3: Flood Fill with Color Picker</title>
    <style>
        canvas { border: 1px solid black; }
        .container { display: flex; justify-content: space-between; align-items: flex-start; margin: 10px; }
        .controls { display: flex; flex-direction: column; gap: 10px; }
        .instructions { text-align: right; }
        .instructions ul { list-style-type: none; padding: 0; }
        .instructions li { margin-bottom: 5px; }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div class="container">
        <div class="controls">
            <label for="fillColor">Выберите цвет заливки: </label>
            <input type="color" id="fillColor" value="#ff0000">
            <button id="clear">Очистить холст</button>
        </div>
        <div class="instructions">
            <ul>
                <li>1. Рисуйте контур левой кнопкой мыши (удерживайте).</li>
                <li>2. Кликните правой кнопкой для заливки.</li>
                <li>3. Убедитесь, что контур замкнут!</li>
            </ul>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('fillColor');
        let isDrawing = false;
        let lastX = 0, lastY = 0;

        // Цвета (в формате RGBA)
        const boundaryColor = [0, 0, 0, 255]; // Черный для границы
        const backgroundColor = [255, 255, 255, 255]; // Белый фон

        // Инициализация холста
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Функция преобразования HEX в RGBA
        function hexToRGBA(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        // Функция сравнения цветов
        function colorsEqual(c1, c2) {
            return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
        }

        // Получение ImageData для всего холста
        function getImageData() {
            return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        // Обновление холста из ImageData
        function putImageData(imageData) {
            ctx.putImageData(imageData, 0, 0);
        }

        // Рисование контура
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Левая кнопка для рисования
                isDrawing = true;
                lastX = e.offsetX;
                lastY = e.offsetY;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(e.offsetX, e.offsetY);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.stroke();
                lastX = e.offsetX;
                lastY = e.offsetY;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isDrawing = false;
            }
        });

        // Заливка по правому клику
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const x = Math.floor(e.offsetX);
            const y = Math.floor(e.offsetY);
            const imageData = getImageData();
            const data = imageData.data;
            const width = canvas.width;
            const idx = (y * width + x) * 4;
            const targetColor = [data[idx], data[idx + 1], data[idx + 2], data[idx + 3]];
            const fillColor = hexToRGBA(colorPicker.value);

            if (colorsEqual(targetColor, fillColor) || colorsEqual(targetColor, boundaryColor)) {
                console.log("Клик на границе или закрашенной области, заливка отменена");
                return;
            }

            const filledPixels = scanlineFill(x, y, imageData, targetColor, fillColor);
            console.log(`Закрашено пикселей: ${filledPixels} цветом ${fillColor}`);
            putImageData(imageData);
        });

        // Кнопка очистки
        document.getElementById('clear').addEventListener('click', () => {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        });

        // Рекурсивный scanline fill
        function scanlineFill(seedX, seedY, imageData, targetColor, fillColor) {
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            if (seedX < 0 || seedX >= width || seedY < 0 || seedY >= height) {
                return 0;
            }

            // Получаем цвет текущей точки
            const idx = (seedY * width + seedX) * 4;
            const currentColor = [data[idx], data[idx + 1], data[idx + 2], data[idx + 3]];

            // Проверка, можно ли закрасить
            if (!colorsEqual(currentColor, targetColor) || colorsEqual(currentColor, fillColor) || colorsEqual(currentColor, boundaryColor)) {
                return 0;
            }

            // Находим левую и правую границы линии
            let leftX = seedX;
            let idxLeft = (seedY * width + leftX) * 4;
            while (leftX >= 0 && colorsEqual([data[idxLeft], data[idxLeft + 1], data[idxLeft + 2], data[idxLeft + 3]], targetColor)) {
                leftX--;
                idxLeft = (seedY * width + leftX) * 4;
            }
            leftX++;

            let rightX = seedX;
            let idxRight = (seedY * width + rightX) * 4;
            while (rightX < width && colorsEqual([data[idxRight], data[idxRight + 1], data[idxRight + 2], data[idxRight + 3]], targetColor)) {
                rightX++;
                idxRight = (seedY * width + rightX) * 4;
            }
            rightX--;

            // Закрашиваем линию
            let filledPixels = 0;
            for (let i = leftX; i <= rightX; i++) {
                const pixelIdx = (seedY * width + i) * 4;
                data[pixelIdx] = fillColor[0];
                data[pixelIdx + 1] = fillColor[1];
                data[pixelIdx + 2] = fillColor[2];
                data[pixelIdx + 3] = fillColor[3];
                filledPixels++;
            }

            // Рекурсивно проверяем соседние строки
            if (seedY > 0) {
                for (let i = leftX; i <= rightX; i++) {
                    filledPixels += scanlineFill(i, seedY - 1, imageData, targetColor, fillColor);
                }
            }
            if (seedY < height - 1) {
                for (let i = leftX; i <= rightX; i++) {
                    filledPixels += scanlineFill(i, seedY + 1, imageData, targetColor, fillColor);
                }
            }

            return filledPixels;
        }
    </script>
</body>
</html>