<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lab 3: Flood Fill with Color Picker</title>
    <style>
        canvas { border: 1px solid black; }
        .container { display: flex; justify-content: space-between; align-items: flex-start; margin: 10px; }
        .controls { display: flex; flex-direction: column; gap: 10px; }
        .instructions { text-align: right; }
        .instructions ul { list-style-type: none; padding: 0; }
        .instructions li { margin-bottom: 5px; }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div class="container">
        <div class="controls">
            <label for="fillColor">Выберите цвет заливки: </label>
            <input type="color" id="fillColor" value="#ff0000">
            <button id="clear">Очистить холст</button>
        </div>
        <div class="instructions">
            <ul>
                <li>1. Рисуйте контур левой кнопкой мыши (удерживайте).</li>
                <li>2. Кликните правой кнопкой для заливки.</li>
                <li>3. Убедитесь, что контур замкнут!</li>
            </ul>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('fillColor');
        let isDrawing = false;
        let lastX = 0, lastY = 0;

        // Цвета (в формате RGBA)
        const boundaryColor = [0, 0, 0, 255]; // Черный для границы
        const backgroundColor = [255, 255, 255, 255]; // Белый фон

        // Инициализация холста
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Функция преобразования HEX в RGBA
        function hexToRGBA(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        // Функция сравнения цветов
        function colorsEqual(c1, c2) {
            return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
        }

        // Получение ImageData для всего холста
        function getImageData() {
            return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        // Обновление холста из ImageData
        function putImageData(imageData) {
            ctx.putImageData(imageData, 0, 0);
        }

        // Рисование контура
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Левая кнопка для рисования
                isDrawing = true;
                lastX = e.offsetX;
                lastY = e.offsetY;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(e.offsetX, e.offsetY);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.stroke();
                lastX = e.offsetX;
                lastY = e.offsetY;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isDrawing = false;
            }
        });

        // Заливка по правому клику
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const x = Math.floor(e.offsetX);
            const y = Math.floor(e.offsetY);
            scanlineFill(x, y);
        });

        // Кнопка очистки
        document.getElementById('clear').addEventListener('click', () => {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        });

        // Нерекурсивный scanline fill
        function scanlineFill(seedX, seedY) {
            if (seedX < 0 || seedX >= canvas.width || seedY < 0 || seedY >= canvas.height) {
                console.log("Клик вне холста!");
                return;
            }

            const imageData = getImageData();
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            // Получаем цвет стартовой точки
            const idx = (seedY * width + seedX) * 4;
            const targetColor = [data[idx], data[idx + 1], data[idx + 2], data[idx + 3]];

            // Получаем текущий цвет заливки из color picker
            const fillColor = hexToRGBA(colorPicker.value);

            // Проверка, не кликнули ли на границу или уже закрашенную область
            if (colorsEqual(targetColor, fillColor) || colorsEqual(targetColor, boundaryColor)) {
                console.log("Клик на границе или закрашенной области, заливка отменена");
                return;
            }

            const stack = [[seedX, seedY]];
            let filledPixels = 0;

            while (stack.length > 0) {
                const [x, y] = stack.pop();

                // Находим левую и правую границы линии
                let leftX = x;
                let idxLeft = (y * width + leftX) * 4;
                while (leftX >= 0 && colorsEqual([data[idxLeft], data[idxLeft + 1], data[idxLeft + 2], data[idxLeft + 3]], targetColor)) {
                    leftX--;
                    idxLeft = (y * width + leftX) * 4;
                }
                leftX++;

                let rightX = x;
                let idxRight = (y * width + rightX) * 4;
                while (rightX < width && colorsEqual([data[idxRight], data[idxRight + 1], data[idxRight + 2], data[idxRight + 3]], targetColor)) {
                    rightX++;
                    idxRight = (y * width + rightX) * 4;
                }
                rightX--;

                // Закрашиваем линию
                for (let i = leftX; i <= rightX; i++) {
                    const pixelIdx = (y * width + i) * 4;
                    data[pixelIdx] = fillColor[0];
                    data[pixelIdx + 1] = fillColor[1];
                    data[pixelIdx + 2] = fillColor[2];
                    data[pixelIdx + 3] = fillColor[3];
                    filledPixels++;
                }

                // Проверяем соседние строки
                if (y > 0) {
                    for (let i = leftX; i <= rightX; i++) {
                        const upIdx = ((y - 1) * width + i) * 4;
                        if (colorsEqual([data[upIdx], data[upIdx + 1], data[upIdx + 2], data[upIdx + 3]], targetColor)) {
                            stack.push([i, y - 1]);
                        }
                    }
                }
                if (y < height - 1) {
                    for (let i = leftX; i <= rightX; i++) {
                        const downIdx = ((y + 1) * width + i) * 4;
                        if (colorsEqual([data[downIdx], data[downIdx + 1], data[downIdx + 2], data[downIdx + 3]], targetColor)) {
                            stack.push([i, y + 1]);
                        }
                    }
                }
            }

            console.log(`Закрашено пикселей: ${filledPixels} цветом ${fillColor}`);
            putImageData(imageData);
        }
    </script>
</body>
</html>